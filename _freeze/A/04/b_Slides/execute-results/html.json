{
  "hash": "52487340c3f931a7ae26feb752d36fb0",
  "result": {
    "engine": "knitr",
    "markdown": "---\nformat: \n  revealjs:\n    css: ../../styles.css\n    slide-number: true\n    show-slide-number: all\n    preview-links: false\n    progress: true\n    history: true\n    hash-type: number\n    theme: default\n    code-block-background: true\n    highlight-style: zenburn\n    code-link: false\n    code-copy: true\n    code-line-numbers: false\n    controls: true\n    pagetitle: \"Multilevel Modeling\"\n    author-meta: \"Jeffrey Girard\"\n    semester: \"Spring 2026\"\n    course: \"PSYC 894\"\n    lecture: \"04b\"\nexecute:\n  echo: true\n  eval: true\n  collapse: false\n  cache: false\n---\n\n::: {.my-title}\n# [Multilevel Modeling]{.blue}\nProcessing Multilevel Data\n\n::: {.my-grey}\n[{{< meta semester >}} | CLAS | {{< meta course >}}]{}<br />\n[Jeffrey M. Girard | Lecture {{< meta lecture >}}]{}\n:::\n\n![](../../img/city-girl.svg){.absolute bottom=30 right=0 width=\"400\"}\n:::\n\n\n::: {.cell}\n\n:::\n\n\n## Roadmap\n\n::: {.columns .pv4}\n\n::: {.column width=\"60%\"}\n1. Data Tidying Recap\n    + *Select, Filter, Mutate*\n\n2. Reshaping Data\n    + *Wide vs. Long Formats*\n    + *Pivoting with `tidyr`*\n\n3. Handling Hierarchy\n    + *Grouping & Summarizing*\n    + *Joining Level 1 & 2 Files*\n    \n:::\n\n::: {.column .tc .pv4 width=\"40%\"}\n{{< lif \"../../icons/map.json\" trigger=hover colors=secondary:#2a76dd class=rc >}}\n:::\n\n:::\n\n# Data Tidying Recap\n\n## The Tidyverse Toolkit\n\n- **`dplyr`** is our primary tool for data manipulation.\n- It uses a set of \"verbs\" to describe actions on data:\n    + `select()`: Pick specific columns\n    + `filter()`: Pick specific rows\n    + `mutate()`: Create or change columns\n\n:::{.fragment}\n- **The Pipe (`|>` or `%>%`)**\n    + Passes the result of one function to the next.\n    + Read it as **\"and then...\"**\n:::\n\n## Example Dataset\n\n\n::: {.cell replace_path='[\"../../data/\",\"\"]'}\n\n```{.r .cell-code}\nlibrary(tidyverse)\nheck <- read_csv(\"heck2011.csv\")\n\n# Take heck AND THEN glimpse it\nheck |> glimpse()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nRows: 6,871\nColumns: 7\n$ school  <dbl> 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2,…\n$ student <dbl> 6701, 6702, 6703, 6704, 6705, 6706, 6707, 6708, 6709, 6710, 67…\n$ female  <dbl> 1, 1, 1, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0,…\n$ ses     <dbl> 0.586, 0.304, -0.544, -0.848, 0.001, -0.106, -0.330, -0.891, 0…\n$ math    <dbl> 47.1400, 63.6100, 57.7100, 53.9000, 58.0100, 59.8700, 62.5556,…\n$ puniv   <dbl> 0.08333333, 0.08333333, 0.08333333, 0.08333333, 0.08333333, 0.…\n$ public  <dbl> 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,…\n```\n\n\n:::\n:::\n\n\n## Select & Filter\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Take heck AND THEN select columns AND THEN filter rows AND THEN print it\nheck_subset <- \n  heck |> \n  select(student, school, math, starts_with(\"p\")) |> # retain these columns\n  filter(math >= 50) |> # retain students with math greater or equal to 50\n  print()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 5,514 × 5\n  student school  math  puniv public\n    <dbl>  <dbl> <dbl>  <dbl>  <dbl>\n1    6702      1  63.6 0.0833      0\n2    6703      1  57.7 0.0833      0\n3    6704      1  53.9 0.0833      0\n4    6705      1  58.0 0.0833      0\n5    6706      1  59.9 0.0833      0\n6    6707      1  62.6 0.0833      0\n# ℹ 5,508 more rows\n```\n\n\n:::\n:::\n\n\n## Mutate\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Take heck AND THEN transform school and create the logmath variable\nheck_transformed <- \n  heck |> \n  mutate(\n    school = factor(school), # Convert to categorical (in place)\n    logmath = log(math)      # Natural log transform (new column)\n  ) |> \n  print()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 6,871 × 8\n  school student female    ses  math  puniv public logmath\n  <fct>    <dbl>  <dbl>  <dbl> <dbl>  <dbl>  <dbl>   <dbl>\n1 1         6701      1  0.586  47.1 0.0833      0    3.85\n2 1         6702      1  0.304  63.6 0.0833      0    4.15\n3 1         6703      1 -0.544  57.7 0.0833      0    4.06\n4 1         6704      0 -0.848  53.9 0.0833      0    3.99\n5 1         6705      0  0.001  58.0 0.0833      0    4.06\n6 1         6706      0 -0.106  59.9 0.0833      0    4.09\n# ℹ 6,865 more rows\n```\n\n\n:::\n:::\n\n\n# Reshaping Data\n\n## The Shape of MLM Data {.fsmaller}\n\n- [Wide Format]{.b .red}\n    + One Row = One **Cluster** (e.g., a subject in longitudinal study)\n    + One Column = One **Time-Specific Score**<br>\n      (e.g., Stress_T1, Stress_T2, ..., Mood_T1, Mood_T2, ...)\n    + ❌ Most MLM software cannot handle this\n\n:::{.fragment}\n- [Long Format]{.b .green}\n    + One Row = One **Observation**<br>\n      (e.g., Time 1 of Person 1, Time 2 of Person 1, ...)\n    + One Column = One **Variable** (e.g., Time, Person, Stress, Mood)\n    + ✅ Most MLM software expects this\n\n:::\n\n## Scenario 1: Simple {.fsmaller}\n\n\n::: {.cell}\n\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Example longitudinal dataset in wide format\nwide_simple\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 2 × 4\n  subject    T1    T2    T3\n    <int> <dbl> <dbl> <dbl>\n1       1    10    14     9\n2       2    12    11    13\n```\n\n\n:::\n:::\n\n\n- This dataset is currently in [wide-format]{.b .green}\n    - We have 2 clusters (subjects), each with its own row\n    - We have 3 time points, each with its own column\n    \n::: {.fragment}\n- But MLM wants it in [long-format]{.b .blue}\n    - We want 6 rows, one per observation (time-specific score)\n    - We want 3 columns: **subject**, **time**, **score**\n    \n:::\n\n## Scenario 1: Simple {.fsmaller}\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Pivot the data longer (from wide-format to long-format)\nlong_simple <- \n  wide_simple |> \n  pivot_longer(\n    cols = c(T1, T2, T3), # which old columns contain our observations?\n    names_to = \"time\",    # what new column should the old column names go to?\n    values_to = \"score\"   # what new column should the old values go to?\n  ) |> \n  print()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 6 × 3\n  subject time  score\n    <int> <chr> <dbl>\n1       1 T1       10\n2       1 T2       14\n3       1 T3        9\n4       2 T1       12\n5       2 T2       11\n6       2 T3       13\n```\n\n\n:::\n:::\n\n\n- We move the old column **names** to a new column (\"time\")\n- We move the old 2x3 block of **values** into a new column (\"score\")\n\n\n## Scenario 2: Realistic {.fsmaller}\n\n\n::: {.cell}\n\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Example longitudinal dataset in very-wide-format\nwide_real\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 2 × 5\n  id    stress_T1 stress_T2 mood_T1 mood_T2\n  <chr>     <dbl>     <dbl>   <dbl>   <dbl>\n1 S001         10        14       5       7\n2 S002         12        11       6       5\n```\n\n\n:::\n:::\n\n\n- Real world data is often a bit more complicated...\n- Here, we have *two* scores per time point: **stress** and **mood**\n    + MLM needs these to be separate columns...\n    + Luckily, they are named consistently as \"variable_time\"\n    + We can leverage this using `names_sep` and `names_to`\n\n## Scenario 2: Realistic {.fsmaller}\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Pivot the data longer (from very-wide-format to long-format)\nlong_real <- \n  wide_real |> \n  pivot_longer(\n    # Which old columns contain our observations?\n    cols = c(starts_with(\"stress\"), starts_with(\"mood\")), \n    # What separates our old column names (e.g., \"stress\" _ \"T1\")\n    names_sep = \"_\",\n    # Map the parts: \".value\" keeps the name as a header, \"time\" takes the suffix\n    names_to = c(\".value\", \"time\")\n  ) |> \n  print()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 4 × 4\n  id    time  stress  mood\n  <chr> <chr>  <dbl> <dbl>\n1 S001  T1        10     5\n2 S001  T2        14     7\n3 S002  T1        12     6\n4 S002  T2        11     5\n```\n\n\n:::\n:::\n\n\n## Why .value is Magic {.fsmaller}\n\nNotice what happened:\n\n1.  It saw `stress_T1`.\n2.  It split it at `_`.\n3.  Because we said `c(\".value\", \"time\")`:\n    +   **\"stress\"** became a **Column Header**.\n    +   **\"T1\"** went into the **`time`** column.\n\n:::{.fragment .mt4}\nThis creates a perfectly formatted MLM dataset with one row per observation, and separate columns for your predictors ($X$) and outcomes ($Y$).\n:::\n\n## Parsing Numbers {.fsmaller}\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# What if we want to extract the numeric part of time (\"T2\" -> 2)?\nlong_real\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 4 × 4\n  id    time  stress  mood\n  <chr> <chr>  <dbl> <dbl>\n1 S001  T1        10     5\n2 S001  T2        14     7\n3 S002  T1        12     6\n4 S002  T2        11     5\n```\n\n\n:::\n:::\n\n\n:::{.fragment}\n\n::: {.cell}\n\n```{.r .cell-code}\n# We can use parse_number() inside of mutate()\nlong_real <- \n  long_real |> \n  mutate(time = parse_number(time)) |> \n  print()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 4 × 4\n  id     time stress  mood\n  <chr> <dbl>  <dbl> <dbl>\n1 S001      1     10     5\n2 S001      2     14     7\n3 S002      1     12     6\n4 S002      2     11     5\n```\n\n\n:::\n:::\n\n:::\n\n## The Payoff: Visualizing Change {.fsmaller}\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Now that our data is in long-format, we can easily plot it by participant!\nggplot(long_real, aes(x = time, y = stress, color = id)) +\n  geom_line() + \n  geom_point() +\n  labs(title = \"Individual Stress Trajectories\") +\n  theme_bw(base_size = 20)\n```\n\n::: {.cell-output-display}\n![](b_Slides_files/figure-revealjs/unnamed-chunk-12-1.png){width=960}\n:::\n:::\n\n\n# Handling Hierarchy\n\n## Split--Apply--Combine\n\nIn MLM, we often need to calculate statistics *per cluster*<br>\n(e.g., school average math score). We do this using `.by`.\n\n:::{.fragment}\n1. **Split** the data into groups (Schools).\n2. **Apply** a calculation to each group (Mean).\n3. **Combine** the results back into the dataframe.\n:::\n\n:::{.fragment}\n- `summarize(.by)` is useful for data exploration\n- `mutate(.by)` will prepare the data for MLM\n:::\n\n## Aggregating (Summarize) {.fsmaller}\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# To create a L2 dataset (e.g., summaries per school), we use summarize(.by)\nschool_means <- \n  heck |> \n  summarize(\n    .by = school,\n    school_math_mean = mean(math),\n    n_students = n()\n  ) |> \n  print()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 419 × 3\n  school school_math_mean n_students\n   <dbl>            <dbl>      <int>\n1      1             59.0         12\n2      2             63.6         13\n3      3             47.6         18\n4      4             65.7         17\n5      5             48.1         17\n6      6             61.0         16\n# ℹ 413 more rows\n```\n\n\n:::\n:::\n\n\n## Annotating (Mutate) {.fsmaller}\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# To simply add L2 summaries to the L1 dataset, we use mutate(.by)\nheck_with_means <- \n  heck |> \n  mutate(\n    .by = school,\n    school_math_mean = mean(math, na.rm = TRUE)\n  ) |> \n  print()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 6,871 × 8\n  school student female    ses  math  puniv public school_math_mean\n   <dbl>   <dbl>  <dbl>  <dbl> <dbl>  <dbl>  <dbl>            <dbl>\n1      1    6701      1  0.586  47.1 0.0833      0             59.0\n2      1    6702      1  0.304  63.6 0.0833      0             59.0\n3      1    6703      1 -0.544  57.7 0.0833      0             59.0\n4      1    6704      0 -0.848  53.9 0.0833      0             59.0\n5      1    6705      0  0.001  58.0 0.0833      0             59.0\n6      1    6706      0 -0.106  59.9 0.0833      0             59.0\n# ℹ 6,865 more rows\n```\n\n\n:::\n:::\n\n\n:::{.callout-tip}\nNote that `school_math_mean` is repeated for every student in the same school. This is what MLM wants!\n:::\n\n## Merging: The Setup {.fsmaller}\n\n\n::: {.cell}\n\n:::\n\n\nSometimes your data comes in separate files per level...\n\n::: {.columns}\n::: {.column width=\"50%\"}\n**1. Level 1 Data (People)**\n\n- Contains individual variables and the grouping ID (country).\n\n\n::: {.cell}\n\n```{.r .cell-code}\nL1_people\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 4 × 4\n    pid sex   income country\n  <int> <chr>  <dbl> <chr>  \n1     1 M         50 Japan  \n2     2 F         55 Japan  \n3     3 F         42 France \n4     4 M         48 France \n```\n\n\n:::\n:::\n\n:::\n\n::: {.column width=\"50%\"}\n**2. Level 2 Data (Countries)**\n\n- Contains cluster-level variables and the same grouping ID (country)\n\n\n::: {.cell}\n\n```{.r .cell-code}\nL2_countries\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 4 × 3\n  country continent   gdp\n  <chr>   <chr>     <dbl>\n1 China   Asia      38.2 \n2 Japan   Asia       6.45\n3 France  Europe     4.29\n4 Germany Europe     6.14\n```\n\n\n:::\n:::\n\n:::\n:::\n\n## Merging: The Join {.fsmaller}\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmerged_data <- \n  left_join(\n    x = L1_people,    # The Level 1 file (Start with the detailed data)\n    y = L2_countries, # The Level 2 file (Bring in the context)\n    by = \"country\"    # The linking variable (cluster ID)\n  ) |> \n  print()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 4 × 6\n    pid sex   income country continent   gdp\n  <int> <chr>  <dbl> <chr>   <chr>     <dbl>\n1     1 M         50 Japan   Asia       6.45\n2     2 F         55 Japan   Asia       6.45\n3     3 F         42 France  Europe     4.29\n4     4 M         48 France  Europe     4.29\n```\n\n\n:::\n:::\n\n\n- Notice that `Asia` and `4.2` were copied for both participants in Japan\n- This creates the rectangular, long-format dataset required for MLM\n- Notice that China and Germany are excluded (no participants from there!)\n",
    "supporting": [
      "b_Slides_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-after-body": [
        "\n<script>\n  // htmlwidgets need to know to resize themselves when slides are shown/hidden.\n  // Fire the \"slideenter\" event (handled by htmlwidgets.js) when the current\n  // slide changes (different for each slide format).\n  (function () {\n    // dispatch for htmlwidgets\n    function fireSlideEnter() {\n      const event = window.document.createEvent(\"Event\");\n      event.initEvent(\"slideenter\", true, true);\n      window.document.dispatchEvent(event);\n    }\n\n    function fireSlideChanged(previousSlide, currentSlide) {\n      fireSlideEnter();\n\n      // dispatch for shiny\n      if (window.jQuery) {\n        if (previousSlide) {\n          window.jQuery(previousSlide).trigger(\"hidden\");\n        }\n        if (currentSlide) {\n          window.jQuery(currentSlide).trigger(\"shown\");\n        }\n      }\n    }\n\n    // hookup for slidy\n    if (window.w3c_slidy) {\n      window.w3c_slidy.add_observer(function (slide_num) {\n        // slide_num starts at position 1\n        fireSlideChanged(null, w3c_slidy.slides[slide_num - 1]);\n      });\n    }\n\n  })();\n</script>\n\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}