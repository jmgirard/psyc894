---
format: 
  revealjs:
    css: ../../styles.css
    slide-number: true
    show-slide-number: all
    preview-links: false
    progress: true
    history: true
    hash-type: number
    theme: default
    code-block-background: true
    highlight-style: zenburn
    code-link: false
    code-copy: true
    code-line-numbers: false
    controls: true
    pagetitle: "Multilevel Modeling"
    author-meta: "Jeffrey Girard"
    semester: "Spring 2026"
    course: "PSYC 894"
    lecture: "04b"
execute:
  echo: true
  eval: true
  collapse: false
  cache: false
---

::: {.my-title}
# [Multilevel Modeling]{.blue}
Processing Multilevel Data

::: {.my-grey}
[{{< meta semester >}} | CLAS | {{< meta course >}}]{}<br />
[Jeffrey M. Girard | Lecture {{< meta lecture >}}]{}
:::

![](../../img/city-girl.svg){.absolute bottom=30 right=0 width="400"}
:::

```{r setup}
#| echo: false
#| message: false

library(here)
source(here("_common.R"))

options(readr.show_col_types = FALSE)
options(tibble.print_max = 6, tibble.print_min = 6)
```

## Roadmap

::: {.columns .pv4}

::: {.column width="60%"}
1. Data Tidying Recap
    + *Select, Filter, Mutate*

2. Reshaping Data
    + *Wide vs. Long Formats*
    + *Pivoting with `tidyr`*

3. Handling Hierarchy
    + *Grouping & Summarizing*
    + *Joining Level 1 & 2 Files*
    
:::

::: {.column .tc .pv4 width="40%"}
{{< lif "../../icons/map.json" trigger=hover colors=secondary:#2a76dd class=rc >}}
:::

:::

# Data Tidying Recap

## The Tidyverse Toolkit

- **`dplyr`** is our primary tool for data manipulation.
- It uses a set of "verbs" to describe actions on data:
    + `select()`: Pick specific columns
    + `filter()`: Pick specific rows
    + `mutate()`: Create or change columns

:::{.fragment}
- **The Pipe (`|>` or `%>%`)**
    + Passes the result of one function to the next.
    + Read it as **"and then..."**
:::

## Example Dataset

```{r}
#| message: false
#| replace_path: ["../../data/", ""]

library(tidyverse)
heck <- read_csv("../../data/heck2011.csv")

# Take heck AND THEN glimpse it
heck |> glimpse()
```

## Select & Filter

```{r}
# Take heck AND THEN select columns AND THEN filter rows AND THEN print it
heck_subset <- 
  heck |> 
  select(student, school, math, starts_with("p")) |> # retain these columns
  filter(math >= 50) |> # retain students with math greater or equal to 50
  print()
```

## Mutate

```{r}
# Take heck AND THEN transform school and create the logmath variable
heck_transformed <- 
  heck |> 
  mutate(
    school = factor(school), # Convert to categorical (in place)
    logmath = log(math)      # Natural log transform (new column)
  ) |> 
  print()
```

# Reshaping Data

## The Shape of MLM Data {.fsmaller}

- [Wide Format]{.b .red}
    + One Row = One **Cluster** (e.g., a subject in longitudinal study)
    + One Column = One **Time-Specific Score**<br>
      (e.g., Stress_T1, Stress_T2, ..., Mood_T1, Mood_T2, ...)
    + ❌ Most MLM software cannot handle this

:::{.fragment}
- [Long Format]{.b .green}
    + One Row = One **Observation**<br>
      (e.g., Time 1 of Person 1, Time 2 of Person 1, ...)
    + One Column = One **Variable** (e.g., Time, Person, Stress, Mood)
    + ✅ Most MLM software expects this

:::

## Scenario 1: Simple {.fsmaller}

```{r}
#| echo: false

wide_simple <- tibble(
  subject = 1:2,
  T1 = c(10, 12),
  T2 = c(14, 11),
  T3 = c(9, 13)
)
```

```{r}
# Example longitudinal dataset in wide format
wide_simple
```

- This dataset is currently in [wide-format]{.b .green}
    - We have 2 clusters (subjects), each with its own row
    - We have 3 time points, each with its own column
    
::: {.fragment}
- But MLM wants it in [long-format]{.b .blue}
    - We want 6 rows, one per observation (time-specific score)
    - We want 3 columns: **subject**, **time**, **score**
    
:::

## Scenario 1: Simple {.fsmaller}

```{r}
# Pivot the data longer (from wide-format to long-format)
long_simple <- 
  wide_simple |> 
  pivot_longer(
    cols = c(T1, T2, T3), # which old columns contain our observations?
    names_to = "time",    # what new column should the old column names go to?
    values_to = "score"   # what new column should the old values go to?
  ) |> 
  print()
```

- We move the old column **names** to a new column ("time")
- We move the old 2x3 block of **values** into a new column ("score")


## Scenario 2: Realistic {.fsmaller}

```{r}
#| echo: false

wide_real <- tibble(
  id = c("S001", "S002"),
  stress_T1 = c(10, 12),
  stress_T2 = c(14, 11),
  mood_T1 = c(5, 6),
  mood_T2 = c(7, 5)
)
```

```{r}
# Example longitudinal dataset in very-wide-format
wide_real
```

- Real world data is often a bit more complicated...
- Here, we have *two* scores per time point: **stress** and **mood**
    + MLM needs these to be separate columns...
    + Luckily, they are named consistently as "variable_time"
    + We can leverage this using `names_sep` and `names_to`

## Scenario 2: Realistic {.fsmaller}

```{r}
# Pivot the data longer (from very-wide-format to long-format)
long_real <- 
  wide_real |> 
  pivot_longer(
    # Which old columns contain our observations?
    cols = c(starts_with("stress"), starts_with("mood")), 
    # What separates our old column names (e.g., "stress" _ "T1")
    names_sep = "_",
    # Map the parts: ".value" keeps the name as a header, "time" takes the suffix
    names_to = c(".value", "time")
  ) |> 
  print()
```

## Why .value is Magic {.fsmaller}

Notice what happened:

1.  It saw `stress_T1`.
2.  It split it at `_`.
3.  Because we said `c(".value", "time")`:
    +   **"stress"** became a **Column Header**.
    +   **"T1"** went into the **`time`** column.

:::{.fragment .mt4}
This creates a perfectly formatted MLM dataset with one row per observation, and separate columns for your predictors ($X$) and outcomes ($Y$).
:::

## Parsing Numbers {.fsmaller}

```{r}
# What if we want to extract the numeric part of time ("T2" -> 2)?
long_real
```

:::{.fragment}
```{r}
# We can use parse_number() inside of mutate()
long_real <- 
  long_real |> 
  mutate(time = parse_number(time)) |> 
  print()
```
:::

## The Payoff: Visualizing Change {.fsmaller}

```{r}
# Now that our data is in long-format, we can easily plot it by participant!
ggplot(long_real, aes(x = time, y = stress, color = id)) +
  geom_line() + 
  geom_point() +
  labs(title = "Individual Stress Trajectories") +
  theme_bw(base_size = 20)
```

# Handling Hierarchy

## Split--Apply--Combine

In MLM, we often need to calculate statistics *per cluster*<br>
(e.g., school average math score). We do this using `.by`.

:::{.fragment}
1. **Split** the data into groups (Schools).
2. **Apply** a calculation to each group (Mean).
3. **Combine** the results back into the dataframe.
:::

:::{.fragment}
- `summarize(.by)` is useful for data exploration
- `mutate(.by)` will prepare the data for MLM
:::

## Aggregating (Summarize) {.fsmaller}

```{r}
# To create a L2 dataset (e.g., summaries per school), we use summarize(.by)
school_means <- 
  heck |> 
  summarize(
    .by = school,
    school_math_mean = mean(math, na.rm = TRUE),
    n_students = n()
  ) |> 
  print()
```

## Annotating (Mutate) {.fsmaller}

```{r}
# To simply add L2 summaries to the L1 dataset, we use mutate(.by)
heck_with_means <- 
  heck |> 
  mutate(
    .by = school,
    school_math_mean = mean(math, na.rm = TRUE)
  ) |> 
  print()
```

:::{.callout-tip}
Note that `school_math_mean` is repeated for every student in the same school. This is what MLM wants!
:::

## Merging: The Setup {.fsmaller}

```{r}
#| echo: false

# Level 1: Participants (nested in countries)
L1_people <- tibble(
  pid = 1:4,
  sex = c("M", "F", "F", "M"),
  income = c(50, 55, 42, 48),
  country = c("Japan", "Japan", "France", "France")
)

# Level 2: Countries
L2_countries <- tibble(
  country = c("China", "Japan", "France", "Germany"),
  continent = c("Asia", "Asia", "Europe", "Europe"),
  gdp = c(38.19, 6.45, 4.29, 6.14)
)
```

Sometimes your data comes in separate files per level...

::: {.columns}
::: {.column width="50%"}
**1. Level 1 Data (People)**

- Contains individual variables and the grouping ID (country).

```{r}
L1_people
```
:::

::: {.column width="50%"}
**2. Level 2 Data (Countries)**

- Contains cluster-level variables and the same grouping ID (country)

```{r}
L2_countries
```
:::
:::

## Merging: The Join {.fsmaller}

```{r}
merged_data <- 
  left_join(
    x = L1_people,    # The Level 1 file (Start with the detailed data)
    y = L2_countries, # The Level 2 file (Bring in the context)
    by = "country"    # The linking variable (cluster ID)
  ) |> 
  print()
```

- Notice that `Asia` and `4.2` were copied for both participants in Japan
- This creates the rectangular, long-format dataset required for MLM
- Notice that China and Germany are excluded (no participants from there!)
