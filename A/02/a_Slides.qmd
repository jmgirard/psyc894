---
format: 
  revealjs:
    css: ../../styles.css
    slide-number: true
    show-slide-number: all
    preview-links: false
    progress: true
    history: true
    hash-type: number
    theme: default
    code-block-background: true
    highlight-style: zenburn
    code-link: false
    code-copy: true
    code-line-numbers: false
    controls: true
    pagetitle: "Multilevel Modeling"
    author-meta: "Jeffrey Girard"
    semester: "Spring 2026"
    course: "PSYC 894"
    lecture: "02a"
execute:
  echo: true
  eval: true
  collapse: false
  cache: false
---

::: {.my-title}
# [Multilevel Modeling]{.blue}
Linear Modeling Review (1/2)

::: {.my-grey}
[{{< meta semester >}} | CLAS | {{< meta course >}}]{}<br />
[Jeffrey M. Girard | Lecture {{< meta lecture >}}]{}
:::

![](../../img/city-girl.svg){.absolute bottom=30 right=0 width="400"}
:::

## Roadmap

::: {.columns .pv4}

::: {.column width="60%"}
1. Simple Regression
  
2. Multiple Regression

3. Categorical Predictors
:::

::: {.column .tc .pv4 width="40%"}
{{< lif "../../icons/map.json" trigger=hover colors=secondary:#2a76dd class=rc >}}
:::

:::

# R Setup

## Load Packages

```{r}
#| message: false

# install.packages(c("easystats", "marginaleffects", "ggplot2"))
library(easystats)
library(marginaleffects)
library(ggplot2)
```

## Example Dataset

```{r}
data_codebook(penguins)
```

::: {.fsmaller}
*Note that this dataset is already included with recent versions of R.*
:::

# Simple Regression

## Simple Regression {.smaller}

::: {.columns .pv4}
::: {.column width="60%"}
-   [Simple regression]{.b .blue} predicts one variable $y$ from another variable $x$ using a straight line

::: {.fragment .mt1}
-   This line is defined by two parameters
    -   The [intercept]{.b .green} is the value of $y$ when $x=0$
    -   The [slope]{.b .green} is the change in $y$ expected for a change of 1 in $x$ (from $x=0$ to $x=1$)
:::

::: {.fragment .mt1}
-   We will use `lm()` to fit regression models
    -   This will solve using ordinary least squares
    -   We need to give it the [data]{.b .green} and a [formula]{.b .green}
:::
:::

::: {.column .tc .pv5 width="40%"}
{{< lif "../../icons/scatter.json" trigger=hover colors=secondary:#2a76dd class=rc >}}
:::
:::

## SR Equation Notation

#### Generic

$$y_i = \beta_0 + \beta_1 x_{i} + \varepsilon_{i}$$

:::{.tc}
where $y_i$ is the continuous response value for observation $i$,<br>
$x_i$ is the continuous predictor value for observation $i$,<br>
$\beta_0$ and $\beta_1$ are the estimated intercept and slope, and<br>
$\varepsilon_i$ is the estimated residual (error) for observation $i$
:::

#### Example

$$\text{MASS}_i = \beta_0 + \beta_1 \text{FLEN}_{i} + \varepsilon_i$$

## SR Formula Notation

#### Generic
:::{.tc}
`y ~ 1 + x`

where *y* is the response variable name,<br>
*1* tells R to estimate the intercept,<br>
and *x* is the continuous predictor variable name
:::

#### Example
:::{.tc}
`body_mass ~ 1 + flipper_len`
:::

## SR Path Diagram {.nostretch}

![](../../diagrams/simple_regression_full.png){width="75%"}

## SR Estimation

```{r}
sr_f <- lm(
  formula = body_mass ~ 1 + flipper_len,
  data = penguins
)
```

:::{.pv4 .fragment}
```{r}
model_parameters(sr_f)
```
:::{.fsmaller}
Intercept: Predict a penguin with 0mm flipper length has --5781g body mass.<br />
Slope: Predict increase of 1mm flipper length increases body mass by 49.7g.<br />
*Conclude: Flipper length is significantly (and positively) related to body mass.*
:::
:::

## SR Centering

```{r}
penguins_c <- center(penguins, select = "flipper_len")
sr_f_c <- lm(formula = body_mass ~ 1 + flipper_len, data = penguins_c)
```

:::{.pv4 .fragment}
```{r}
compare_parameters(sr_f, sr_f_c, select = "{estimate}{stars}")
```
:::{.fsmaller}
The slope doesn't change, but the intercept does and is now the predicted body mass for a penguin with *average* flipper length (rather than 0mm).
:::
:::

## SR Standardizing

```{r}
penguins_z <- standardize(penguins, select = c("body_mass", "flipper_len"))
sr_f_z <- lm(formula = body_mass ~ 1 + flipper_len, data = penguins_z)
```

:::{.pv4 .fragment}
```{r}
compare_parameters(sr_f, sr_f_z, select = "{estimate}{stars}")
```
:::{.fsmaller}
The intercept is now zero and the slope is now the change in body mass in SD units (rather than grams) associated with a change of 1 SD in flipper length.
:::
:::

## SR Visualization

```{r}
#| fig-asp: 0.75

pred_srf <- estimate_relation(sr_f, by = "flipper_len")
plot(pred_srf)
```

## Visualization Customization

```{r}
#| fig-asp: 0.75

plot(pred_srf, show_data = TRUE, dot_size = 5, line_size = 1.5) +
  scale_y_continuous(limits = c(2500, 6500)) +
  labs(x = "Flipper length (mm)", y = "Body mass (g)") +
  theme_bw(base_size = 30)
```

# Multiple Regression

## Multiple Regression {.smaller}

::: {.columns .pv4}
::: {.column width="60%"}
-   We can also include [multiple predictors]{.b .blue} to assess the [partial effect]{.b .green} of each predictor
    -   This allows us to account for the variance shared by the predictors and the outcome

::: {.fragment .mt1}
-   This changes the slopes' interpretations
    -   The slope of $x_1$ is no longer just the change in $y$ expected for a change of 1 in $x_1$
    -   It is now the change in $y$ expected for a change of 1 in $x_1$ **when controlling for $x_2$**
    -   The slope of $x_2$ similarly controls for $x_1$
:::
:::

::: {.column .tc .pv5 width="40%"}
{{< lif "../../icons/venn.json" trigger=hover colors=secondary:#2a76dd class=rc >}}
:::
:::

## MR Equation Notation

#### Generic
$$y_i = \beta_0 + \sum_{p=1}^P \beta_p x_{pi} + \varepsilon_{i}$$

:::{.tc}
where $P$ is the number of predictors
:::

#### Example
$$\text{MASS}_i = \beta_0 + \beta_1 \text{FLEN}_{i} + \beta_2 \text{BDEP}_{i} + \varepsilon_i$$

## MR Formula Notation

#### Generic
:::{.tc}
`y ~ 1 + x1 + ... + xP`

where $\text{x1},\ldots,\text{xP}$ are the predictor variable names
:::

#### Example
:::{.tc}
`body_mass ~ 1 + flipper_len + bill_dep`
:::

## MR Path Diagram {.nostretch}
![](../../diagrams/multiple_regression_full.png){width="70%"}

## MR Estimation

```{r}
#| echo: true

mr_fb <- lm(
  formula = body_mass ~ 1 + flipper_len + bill_dep,
  data = penguins
)
```

:::{.pv4 .fragment}
```{r}
#| echo: true

model_parameters(mr_fb)
```

::: {.fsmaller}
The intercept is body mass when all predictors equal 0. Flipper length was significantly related to body mass while controlling for bill depth. Bill depth was not significantly related to body mass while controlling for flipper length.
:::
:::

## SR vs. MR Estimates

```{r}
#| echo: true

sr_b <- lm(body_mass ~ 1 + bill_dep, data = penguins)
```

:::{.pv4 .fragment}
```{r}
#| echo: true
compare_parameters(sr_f, sr_b, mr_fb, select = "{estimate}{stars}")
```

:::

:::{.f1 .fragment}
- The slopes from SR are called "zero-order" (total) effects.
- The slopes from MR are called "partial" (unique) effects.
:::

## SR vs. MR Visualization (FLEN)

:::{.columns}

:::{.column width="50%"}
```{r}
#| fig-asp: 0.75

pred_srf <- estimate_relation(
  sr_f, by = "flipper_len"
)
plot(pred_srf) + theme_bw(30)
```
:::

:::{.column width="50%"}
```{r}
#| fig-asp: 0.75

pred_mrf <- estimate_relation(
  mr_fb, by = "flipper_len"
)
plot(pred_mrf) + theme_bw(30)
```
:::
:::

## SR vs. MR Visualization (BDEP)

:::{.columns}

:::{.column width="50%"}
```{r}
#| fig-asp: 0.75

pred_srb <- estimate_relation(
  sr_b, by = "bill_dep"
)
plot(pred_srb) + theme_bw(30)
```
:::

:::{.column width="50%"}
```{r}
#| fig-asp: 0.75

pred_mrb <- estimate_relation(
  mr_fb, by = "bill_dep"
)
plot(pred_mrb) + theme_bw(30)
```

:::
:::

# Categorical Predictors

## Categorical Predictors {.smaller}

::: {.columns .pv4}
::: {.column width="60%"}
-   To include categorical predictors in regression models, we can use [dummy coding]{.b .blue}
    -   This creates binary predictor variables

::: {.fragment .mt1}
-   One [reference group]{.b .green} does not get a slope
    -   Instead, it controls the model intercept
    -   All other groups' slopes are just deviations from the intercept
:::

::: {.fragment .mt1}
-   There is no need to create dummy codes in R
    -   Just include a [factor]{.b .green} as a predictor variable
    -   The **first level** will be the reference group
:::
:::

::: {.column .tc .pv5 width="40%"}
{{< lif "../../icons/theater.json" trigger=hover colors=secondary:#2a76dd class=rc >}}
:::
:::

# Categorical SR

## CSR Equation Notation {.smaller}

#### Generic
$$y_i = \beta_0 + \sum_{c=1}^{C-1} \beta_c d_{ci} + \varepsilon_{i}$$

:::{.tc}
where $C$ is the number of levels in the categorical predictor and<br>
$d_{ci}$ represents whether observation $i$ has level $c$ ($0$: no, $1$: yes)
:::

#### Example 1
$$\text{MASS}_i = \beta_0 + \beta_1 \text{MALE}_{i} + \varepsilon_i$$

#### Example 2
$$\text{MASS}_i = \beta_0 + \beta_1 \text{CHIN}_i + \beta_2 \text{GENT}_i + \varepsilon_i$$

## CSR Formula Notation

#### Generic
:::{.tc}
`y ~ 1 + f`

where *f* is an unordered factor and<br>
the first level is the reference group
:::

#### Example 1
:::{.tc}
`body_mass ~ 1 + sex`
:::

#### Example 2
:::{.tc}
`body_mass ~ 1 + species`
:::

## CSR Path Diagram (2 Levels) {.nostretch}

![](../../diagrams/categorical_regression_full2.png){width="70%"}

## CSR Path Diagram (3 Levels) {.nostretch}

![](../../diagrams/categorical_regression_full3.png){width="70%"}

## Data Prep

The `sex` and `species` variables are already factors!


```{r}
xtabs(formula = ~ sex + species, data = penguins)
```


But if they weren't, we would need to convert them:

```{r}
#| eval: false

penguins$sex <- factor(penguins$sex)
penguins$species <- factor(penguins$species)
```

## CSR Estimation (2 levels)

```{r}
csr_sx <- lm(
  formula = body_mass ~ 1 + sex,
  data = penguins
)
```

:::{.pv4 .fragment}
```{r}
model_parameters(csr_sx)
```

:::{.fsmaller}
Intercept: The predicted body mass of the reference group (female).<br />
Slope: The difference between the named (male) and reference groups.<br />
*On average, males had significantly higher body mass than females.*
:::
:::

## CSR Means (2 levels)

```{r}
pred_sx <- estimate_means(csr_sx, by = "sex", estimate = "average")
pred_sx
```

:::{.fsmaller}
The average body mass was approx. 3862 for females and 4546 for males.
:::

## CSR Visualization (2 levels)

```{r}
#| fig-asp: 0.75

plot(pred_sx, dot_size = 5, line_size = 1.5) + 
  scale_y_continuous(limits = c(3500, 5000)) +
  labs(x = "Sex", y = "Body Mass (g)") +
  theme_bw(base_size = 30)
```

## CSR Estimation (3 levels)

```{r}
csr_sp <- lm(
  formula = body_mass ~ 1 + species,
  data = penguins
)
```

:::{.pv4 .fragment}
```{r}
#| echo: true

model_parameters(csr_sp)
```

:::{.fsmaller}
Intercept: Estimated body mass for reference group (Adelie)<br />
Slopes: Difference between named group and reference group<br />
*Note: This table *does not* compare the Chinstrap and Gentoo groups!*
:::
:::

## CSR Means (3 levels)
```{r}
pred_sp <- estimate_means(csr_sp, by = "species")
pred_sp
```


## CSR Visualization (3 levels)

```{r}
#| fig-asp: 0.75

plot(pred_sp, dot_size = 5, line_size = 1.5) +
  labs(x = "Species", y = "Body Mass (g)") +
  theme_bw(base_size = 30)
```

## CSR Pairwise Contrasts

```{r}
estimate_contrasts(
  model = csr_sp, 
  contrast = "species", 
  comparison = "pairwise", # compare pairs of groups
  estimate = "average",
  p_adjust = "holm"
)
```

## CSR Deviation Contrasts

```{r}
estimate_contrasts(
  model = csr_sp, 
  contrast = "species",
  comparison = "meandev", # compare groups to mean of all
  estimate = "average",
  p_adjust = "holm"
)
```

# Categorical MR

## CMR Equation Notation {.smaller}

#### Generic
$$y_i = \beta_0 + \sum_{p=1}^P \beta_p x_{pi} + 
\sum_{k=1}^K \sum_{c=1}^{C_k-1} \beta_{kc} d_{kci}+ 
\varepsilon_{i}$$

:::{.tc}
where $P$ is the number of continuous predictors,<br>
$K$ is the number of categorical predictors (each with $C_k$ levels),<br>
and $d_{kci}$ is a dummy code for obs. $i$ in level $c$ of predictor $k$
:::

#### Example
$$\text{MASS}_i = \beta_0 + \beta_1 \text{FLEN}_i + \beta_2 \text{MALE}_{i} + \\
\beta_3 \text{CHIN}_i + \beta_4 \text{GENT}_i + \varepsilon_i$$

## CMR Formula Notation

#### Generic
:::{.tc}
`y ~ 1 + (x1 + ... + xP) + (f1 + ... + fK)`

where $\text{x1},\ldots,\text{xP}$ are continuous predictors,<br>
$\text{f1},\ldots,\text{fK}$ are unordered factor predictors, and<br>
the parentheses are optional (for clarity only)
:::

#### Example
:::{.tc}
`body_mass ~ 1 + flipper_len + sex + species`
:::


## CMR Path Diagram

![](../../diagrams/complex_regression_full.png)

## CMR Estimation

```{r}
#| echo: true

cmr <- lm(
  formula = body_mass ~ 1 + flipper_len + sex + species,
  data = penguins
)
```

:::{.pv4 .fragment}
```{r}
#| echo: true

model_parameters(cmr)
```

:::

## CMR Visualization: Continuous

```{r}
#| fig-asp: 0.75

pred_cmrf <- estimate_relation(cmr, by = "flipper_len", estimate = "average")
plot(pred_cmrf, dot_size = 5, line_size = 1.5) +
  labs(x = "Flipper Length (mm)", y = "Body Mass (g)", 
       subtitle = "Controlling for Sex and Species") + 
  theme_bw(base_size = 30)
```

## CMR Means

```{r}
pred_cmrs <- estimate_means(cmr, by = "species", estimate = "average")
pred_cmrs
```

## CMR Visualization: Categorical

```{r}
#| fig-asp: 0.75

plot(pred_cmrs, dot_size = 5, line_size = 1.5) +
  labs(x = "Species", y = "Body Mass (g)", 
       subtitle = "Controlling for Sex and Flipper Length") + 
  theme_bw(base_size = 30)
```

## CMR Pairwise Contrasts

```{r}
estimate_contrasts(
  model = cmr,
  contrast = "species",
  comparison = "pairwise", # compare pairs of groups
  estimate = "average",
  p_adjust = "holm"
)
```

## CMR Deviation Contrasts

```{r}
estimate_contrasts(
  model = cmr,
  contrast = "species",
  comparison = "meandev", # compare groups to mean of all
  estimate = "average",
  p_adjust = "holm"
)
```

